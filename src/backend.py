import yaml
import subprocess
import os
import sys
import re
import json
from data_model import TempRange

THINKFAN_CONF_PATH = "/etc/thinkfan.conf"
HELPER_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), "save_helper.py"))

def discover_sensors():
    """
    Runs 'sensors -j' and parses the output to get a list of all
    individual temperature sensors on the system.
    """
    try:
        result = subprocess.run(
            ["sensors", "-j"], 
            capture_output=True, 
            text=True, 
            check=True
        )
        sensor_data = json.loads(result.stdout)
    except Exception as e:
        print(f"Error discovering sensors: {e}", file=sys.stderr)
        return []

    all_sensors = []
    for device_name, device_info in sensor_data.items():
        hwmon_name = device_name.split('-')[0]
        for feature_name, feature_data in device_info.items():
            if not isinstance(feature_data, dict): continue
            for key in feature_data:
                if key.endswith("_input") and key.startswith("temp"):
                    index = int(re.search(r'temp(\d+)_input', key).group(1))
                    all_sensors.append({
                        'device': hwmon_name,
                        'label': feature_name,
                        'index': index
                    })
    return all_sensors

def save_content_to_thinkfan(content):
    """
    Generic helper function that saves any string content to the thinkfan.conf
    file using the privileged helper script.
    """
    try:
        command = ["pkexec", sys.executable, HELPER_PATH, THINKFAN_CONF_PATH, content]
        result = subprocess.run(command, capture_output=True, text=True)
        
        if result.returncode == 0:
            return True
        else:
            print(f"Helper script failed: {result.stderr}", file=sys.stderr)
            return False
    except Exception as e:
        print(f"Error executing helper script: {e}", file=sys.stderr)
        return False

def generate_config_content(selected_sensors):
    """
    Generates the full text content for a new thinkfan.conf file based on
    the user's sensor selection from the wizard.
    """
    if not selected_sensors:
        return ""

    output_str = "# Autogenerated by thinkfan-ui Configuration Wizard\n\n"
    output_str += "fans:\n"
    output_str += "  - tpacpi: /proc/acpi/ibm/fan\n\n"
    output_str += "sensors:\n"

    sensor_groups = {}
    for sensor in selected_sensors:
        device_name = sensor['device']
        if device_name not in sensor_groups:
            sensor_groups[device_name] = []
        sensor_groups[device_name].append(sensor)

    for device, sensors_in_group in sensor_groups.items():
        indices = sorted([s['index'] for s in sensors_in_group])
        output_str += f"  - hwmon: /sys/class/hwmon\n"
        output_str += f"    name: {device}\n"
        output_str += f"    indices: {str(indices)}\n"
        output_str += f"    # Mappings for {device}:\n"
        sorted_sensors_in_group = sorted(sensors_in_group, key=lambda s: s['index'])
        for sensor in sorted_sensors_in_group:
            output_str += f"    #   {sensor['index']}: {sensor['label']}\n"
        output_str += "\n"

    output_str += "levels:\n"

    default_levels = [
        [0, 0, 55], [2, 50, 65], [4, 60, 75],
        [7, 70, 85], [127, 80, 100]
    ]

    if len(selected_sensors) == 1:
        output_str += "# Using simple syntax as only one sensor is active.\n"
        for level in default_levels:
            output_str += f"  - {str(level)}\n"
    else:
        output_str += "# Using detailed syntax for multiple sensors.\n"
        output_str += "# A default curve has been applied to all sensors.\n"
        num_sensors = len(selected_sensors)
        for level, min_temp, max_temp in default_levels:
            lower_limits = [min_temp] * num_sensors
            upper_limits = [max_temp] * num_sensors
            output_str += f"  - speed: {level}\n"
            output_str += f"    lower_limit: {str(lower_limits)}\n"
            output_str += f"    upper_limit: {str(upper_limits)}\n"

    return output_str.replace("'", "")

def load_curve_from_thinkfan():
    """
    Reads /etc/thinkfan.conf and returns a dictionary where keys are sensor
    names/groups and values are their corresponding fan curves (lists of TempRange).
    Supports both simple and detailed syntax.
    """
    try:
        with open(THINKFAN_CONF_PATH, 'r') as f:
            config = yaml.safe_load(f)
    except Exception as e:
        print(f"Error reading {THINKFAN_CONF_PATH}: {e}", file=sys.stderr)
        return {}

    if not isinstance(config, dict) or 'sensors' not in config or 'levels' not in config:
        return {}

    sensor_map = []
    sensor_names = []
    for sensor_block in config.get('sensors', []):
        if isinstance(sensor_block, dict) and 'name' in sensor_block and 'indices' in sensor_block:
            name = sensor_block['name']
            if name not in sensor_names:
                sensor_names.append(name)
            for index in sensor_block['indices']:
                sensor_map.append({'name': name, 'index': index})

    if not sensor_map:
        return {}

    curves = {}
    levels_data = config.get('levels', [])
    if not levels_data:
        return {}

    first_level_entry = levels_data[0]

    if isinstance(first_level_entry, list):
        curve_key = "+".join(sensor_names) if sensor_names else "All Sensors"
        curves[curve_key] = []
        for entry in levels_data:
            if isinstance(entry, list) and len(entry) == 3:
                level, min_temp, max_temp = entry
                if level == 127:
                    level = "Disengaged"
                curves[curve_key].append(TempRange(min_temp=min_temp, max_temp=max_temp, level=level))

    elif isinstance(first_level_entry, dict):
        for name in sensor_names:
            curves[name] = []

        for level_entry in levels_data:
            if not all(k in level_entry for k in ['speed', 'lower_limit', 'upper_limit']):
                continue

            level = level_entry['speed']
            if level == 127:
                level = "Disengaged"

            processed_sensors_for_this_level = set()
            for i, sensor_info in enumerate(sensor_map):
                sensor_name = sensor_info['name']
                if sensor_name in processed_sensors_for_this_level:
                    continue

                try:
                    min_temp = level_entry['lower_limit'][i]
                    max_temp = level_entry['upper_limit'][i]
                    curves[sensor_name].append(TempRange(min_temp=min_temp, max_temp=max_temp, level=level))
                    processed_sensors_for_this_level.add(sensor_name)
                except (IndexError, TypeError):
                    continue
    
    return curves

def save_curve_to_thinkfan(curves_dict):
    """
    Writes a dictionary of curves to /etc/thinkfan.conf using detailed syntax.
    """
    header_lines = []
    sensor_map = []
    
    try:
        with open(THINKFAN_CONF_PATH, 'r') as f:
            current_section = None
            for line in f:
                stripped_line = line.strip()
                if stripped_line.startswith('sensors:'):
                    current_section = 'sensors'
                elif stripped_line.startswith('levels:'):
                    break
                
                header_lines.append(line)
                
                if current_section == 'sensors' and stripped_line.startswith('name:'):
                    name = stripped_line.split(':')[1].strip()
                if current_section == 'sensors' and stripped_line.startswith('indices:'):
                    indices_str = stripped_line.split(':')[1].strip()
                    indices = yaml.safe_load(indices_str)
                    for index in indices:
                        sensor_map.append({'name': name, 'index': index})

    except FileNotFoundError:
        return False

    final_content = "".join(header_lines).strip() + "\n\nlevels:\n"
    
    # Get a sorted list of unique levels from all curves
    all_levels = set()
    for curve in curves_dict.values():
        for temp_range in curve:
            all_levels.add(temp_range.level)
    
    sorted_levels = sorted(list(all_levels), key=lambda x: (isinstance(x, str), x))

    for level in sorted_levels:
        speed = 127 if str(level) == 'Disengaged' else level
        final_content += f"  - speed: {speed}\n"
        
        lower_limits = []
        upper_limits = []
        
        for sensor in sensor_map:
            sensor_name = sensor['name']
            curve = curves_dict.get(sensor_name, [])
            
            found_range = next((r for r in curve if r.level == level), None)
            
            if found_range:
                lower_limits.append(found_range.min_temp)
                upper_limits.append(found_range.max_temp)
            else:
                # Fallback if a level is missing for a sensor
                lower_limits.append(0)
                upper_limits.append(120)

        final_content += f"    lower_limit: {str(lower_limits)}\n"
        final_content += f"    upper_limit: {str(upper_limits)}\n"

    return save_content_to_thinkfan(final_content.replace("'", ""))
