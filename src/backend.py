import yaml
import subprocess
import os
import sys
import re
import json
from data_model import TempRange

THINKFAN_CONF_PATH = "/etc/thinkfan.conf"
HELPER_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), "save_helper.py"))

def discover_sensors():
    """
    Runs 'sensors -j' and parses the output to get a list of all
    individual temperature sensors on the system.
    """
    try:
        result = subprocess.run(
            ["sensors", "-j"], 
            capture_output=True, 
            text=True, 
            check=True
        )
        sensor_data = json.loads(result.stdout)
    except Exception as e:
        print(f"Error discovering sensors: {e}", file=sys.stderr)
        return []

    all_sensors = []
    for device_name, device_info in sensor_data.items():
        hwmon_name = device_name.split('-')[0]
        for feature_name, feature_data in device_info.items():
            if not isinstance(feature_data, dict): continue
            for key in feature_data:
                if key.endswith("_input") and key.startswith("temp"):
                    index = int(re.search(r'temp(\d+)_input', key).group(1))
                    all_sensors.append({
                        'device': hwmon_name,
                        'label': feature_name,
                        'index': index
                    })
    return all_sensors

def save_content_to_thinkfan(content):
    """
    Generic helper function that saves any string content to the thinkfan.conf
    file using the privileged helper script.
    """
    try:
        command = ["pkexec", sys.executable, HELPER_PATH, THINKFAN_CONF_PATH, content]
        result = subprocess.run(command, capture_output=True, text=True)
        
        if result.returncode == 0:
            return True
        else:
            print(f"Helper script failed: {result.stderr}", file=sys.stderr)
            return False
    except Exception as e:
        print(f"Error executing helper script: {e}", file=sys.stderr)
        return False

def generate_config_content(selected_sensors):
    """
    Generates the full text content for a new thinkfan.conf file based on
    the user's sensor selection from the wizard.
    """
    if not selected_sensors:
        return ""

    # --- Preamble and Fans Section ---
    output_str = "# Autogenerated by thinkfan-ui Configuration Wizard\n\n"
    output_str += "fans:\n"
    output_str += "  - tpacpi: /proc/acpi/ibm/fan\n\n"

    # --- Sensors Section ---
    output_str += "sensors:\n"

    # Group selected sensors by their device name to create clean blocks
    sensor_groups = {}
    for sensor in selected_sensors:
        device_name = sensor['device']
        if device_name not in sensor_groups:
            sensor_groups[device_name] = []
        sensor_groups[device_name].append(sensor['index'])

    for device, indices in sensor_groups.items():
        indices.sort()
        output_str += f"  - hwmon: /sys/class/hwmon\n"
        output_str += f"    name: {device}\n"
        output_str += f"    indices: {str(indices)}\n"

    # --- Levels Section (Conditional Syntax) ---
    output_str += "\nlevels:\n"

    default_levels = [
        [0, 0, 55],
        [2, 50, 65],
        [4, 60, 75],
        [7, 70, 85],
        [127, 80, 100]
    ]

    # Scenario 1: A single sensor was selected. Use the simple syntax.
    if len(selected_sensors) == 1:
        output_str += "# Using simple syntax as only one sensor is active.\n"
        for level in default_levels:
            output_str += f"  - {str(level)}\n"
            
    # Scenario 2: Multiple sensors were selected. Use the detailed syntax.
    else:
        output_str += "# Using detailed syntax for multiple sensors.\n"
        output_str += "# A default curve has been applied to all sensors.\n"
        
        num_sensors = len(selected_sensors)
        for level, min_temp, max_temp in default_levels:
            # Create limit lists by repeating the value for each sensor
            lower_limits = [min_temp] * num_sensors
            upper_limits = [max_temp] * num_sensors
            
            output_str += f"  - speed: {level}\n"
            output_str += f"    lower_limit: {str(lower_limits)}\n"
            output_str += f"    upper_limit: {str(upper_limits)}\n"

    # The str() representation of a list uses single quotes, but yaml prefers no quotes.
    return output_str.replace("'", "")


def load_curve_from_thinkfan():
    """
    Reads /etc/thinkfan.conf and converts the 'levels' section
    into a list of TempRange objects, supporting both simple and detailed syntax.
    """
    try:
        with open(THINKFAN_CONF_PATH, 'r') as f:
            config = yaml.safe_load(f)
    except Exception as e:
        print(f"Error reading {THINKFAN_CONF_PATH}: {e}", file=sys.stderr)
        return []

    if 'levels' not in config or not isinstance(config['levels'], list):
        return []

    total_sensor_inputs = 0
    if 'sensors' in config and isinstance(config['sensors'], list):
        for sensor_block in config['sensors']:
            if isinstance(sensor_block, dict) and 'indices' in sensor_block:
                total_sensor_inputs += len(sensor_block['indices'])

    temp_ranges = []
    for entry in config['levels']:
        level, min_temp, max_temp = None, None, None

        if isinstance(entry, list) and len(entry) == 3:
            level, min_temp, max_temp = entry

        elif isinstance(entry, dict) and all(k in entry for k in ['speed', 'lower_limit', 'upper_limit']):
            level = entry['speed']
            lower_limits = entry['lower_limit']
            upper_limits = entry['upper_limit']

            for temp in lower_limits:
                if temp != 0:
                    min_temp = temp
                    break
            for temp in upper_limits:
                if temp != 120:
                    max_temp = temp
                    break
        
        if all(v is not None for v in [level, min_temp, max_temp]):
            if level == 127:
                level = "Disengaged"
            temp_ranges.append(TempRange(min_temp=min_temp, max_temp=max_temp, level=level))
    
    return temp_ranges


def save_curve_to_thinkfan(temp_ranges):
    """
    Writes a list of TempRange objects to the 'levels' section
    of /etc/thinkfan.conf, preserving existing comments and structure.
    """
    header_lines = []
    try:
        with open(THINKFAN_CONF_PATH, 'r') as f:
            for line in f:
                if line.strip().startswith('levels:'):
                    break
                header_lines.append(line)
    except FileNotFoundError:
        header_lines.append("# thinkfan configuration file\n\n")
        header_lines.append("fans:\n")
        header_lines.append("  - tpacpi: /proc/acpi/ibm/fan\n\n")
        header_lines.append("sensors:\n")
        header_lines.append("  - hwmon: /sys/class/hwmon\n")
        header_lines.append("    name: coretemp\n")
        header_lines.append("    indices: [1]\n\n")

    final_content = "".join(header_lines).strip() + "\n\nlevels:\n"

    disengaged_comment_added = False
    for temp_range in temp_ranges:
        level = temp_range.level
        is_disengaged = False
        if str(level) == 'Disengaged':
            level = 127
            is_disengaged = True
        
        if is_disengaged and not disengaged_comment_added:
            final_content += "  # BEWARE: 127 aka disengaged or full-speed. In this level, the EC disables\n"
            final_content += "  # the speed-locked closed-loop fan control and drives the fan as fast as\n"
            final_content += "  # it can go, which might exceed hardware limits. Use with caution.\n"
            disengaged_comment_added = True
            
        final_content += f"  - [{level}, {temp_range.min_temp}, {temp_range.max_temp}]\n"

    # Call the generic save helper to write the content
    return save_content_to_thinkfan(final_content)
